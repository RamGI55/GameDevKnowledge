
All unreal objects are managed under the unique object handling system. All unreal objects have inherited `UObject`.  `UCLASS` marco makes the `UObject` under the handling system aware of them. 
#### What is CDO? 

Each `UCLASS` maintains one object called the **Class Default Object** (CDO) 
CDO is considered to be the basic template object, generated by the class constructor and **cannot be modified** once it is generated.

#### How to Access the UObject? 

Both the `UCLASS` and the CDO can be retrieved for a given object instance. You can access anytime, and anywhere using the `GetClass()` function. 

#### UObject Creation 

**All `UObject`s are initialised on engine startup, and the engine calls their default constructor.**
(UObject called -> Engine Called the Default Constructors.)
Due to the initialisation process, `UObject` do not support the constructor arguments, but optional. 

As the unreal guideline, `UObject` constructors should be **as lightweight as possible** and only initialise the default values and subobjects. Also, it is recommended to initialise the default value in the header file directly according to the coding guideline. [^1]

#### Construction of the UObject 

UObject should only be constructed using NewObject at runtime, or CreateDefaultSubObject for constructors.

| Function                        | Description                                                                                                                                                                                                                                                                                               |
| ------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `CreateDefaultSubObject<class>` | Creates a component or subobject that provides a method for creating a child class and returning the parent class.<br><br>*When creating a default subobject, because they are constructed at engine startup, the class constructor of a UObject should only work with local data or load static assets.* |
| `NewObject<class>`              | Creates a new instance with optional parameters for all available creation options. Offers a wide range of flexibility, including simple use cases with an automatically generated name.                                                                                                                  |
| `new`                           | Create the object in the specific low-level environment, similar as the C++ `new`                                                                                                                                                                                                                         |
#### Create UObject Instance 

##### NewObject

```cpp 
template<class T>
T* NewObject
{ 
	UObject* Outer = (UOjbect*)GetTransitPackage(),
	UClass* Class=T::StaticClass()
}
```

`NewObject()` function overloaded in multiple structure in `UObjectGlobals.h`. The code above is the basic form of the NewObejct(), which takes the `UObject` Outer and `UClass` information to generate the classes. 

```cpp 
UItemData* ItemData = NewObject<UItemData>(); 

// You can generate the UObject with the parameter. 
UItemData* ItemDataWithParm = NewObject<UItemData> (this, UItemData::StaticClass()); 
```


```cpp 
template<class T>
T* NewObject
(
    UObject* Outer, 
    FName Name, 
    EObjectFlags Flags = RF_NoFlags, 
    UObject const* Template=NULL
)
```

You can also designate the new object name and template object as the variable of the new object. Flag is the FObjectFlagsEnum value which can set the object type, gabarge collection rules and object lifetime. 

| Type               | Name                 | Description                                                                             | When to Use                                                                                                                                   |
| ------------------ | -------------------- | --------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------- |
| Object type        | `RF_Public`          | This object is visible outside its containing package.                                  | - When creating assets that can be referenced from other packages<br>- Objects that should appear in the Content Browser in the editor        |
|                    | `RF_StandAlone`      | This object will remain in an editable state even when not referenced.                  | - When assets need to be saved in a package even if not referenced by other objects<br>- Assets that should exist independently in the editor |
| Gabarge Collection | `RF_MarkAsRootSet`   | This object will not be deleted by the garbage collector even if nothing references it. | - Singleton objects that must persist for the entire game lifetime<br>- Critical system objects that are manually managed                     |
|                    | `RF_TagGarbargeTemp` | This object is marked for use by various utilities that use garbage collection.         | - When temporary marking is needed during garbage collection<br>- When implementing custom garbage collection utilities                       |
| Object Lifetime    | `RF_AsyncLoading`    | This object is being loaded asynchronously.                                             | - When loading assets in the background<br>- When tracking object state in streaming systems                                                  |
|                    | `RF_NeedPostLoad`    | This object needs to be post-loaded.                                                    | - When an object requires additional initialisation after deserialisation<br>- Objects that need PostLoad() to be called                      |
Check the note for the more specific examples of the each flags. [[FObjectFlagsEnum]][^2]


#### Property and Function Types 

`UObject` must be marked as the unique macro to maintain `UObject` under the object management system in Unreal. `UPROPERTY` and `UFUNCION` are the marco can managment system catch the `UObject`. 
##### UPROPERTY 

``` cpp 
UPROPERTY([specifier, specifier], [meta(key=value, key=value, ... )])
Type VariableName; 
```
##### UFUNCTION 

```cpp 
UFUNCTION([specifier, specifier], [meta(key=value, key=value, ... )])
ReturnType FunctionName ([Parameter, Parameter, ...]); 
```

### Unreal Header Tool 

Unreal C++ file has the special header format which is automatically generated by the engine. 
You might notice those format is in the unreal c++ file, when you generate the c++ file in the unreal editor.

```cpp 
	#pragma once

	#include 'Object.h'
	#include 'MyObject.generated.h'
	
	UCLASS()
	class MYPROJECT_API UMyObject : public UObject
	{
		GENERATED_BODY()

	};
```

This is the basic structure for UObject-derivative which assumes as the one of the UObject.

#### Updating Objects 

Ticking refers is the how to Objects are updated in Unreal Engine. All actors has the ability to be ticked by each frame, can update in realtime like cacluations or actions as necessary. 

Actors and ActorComponent has their `Tick()` functions. 

UObject, however, must inheriting from `FTickablGameObject` class using the inherits class specifier, then implement the `Tick()` function. 

#### Destroying Objects 

Object destruction is automatically handled by the garbard collection system when an obecjt is no longer referenced. 

More specifically, `UPROPERTY` pointers, engine containers, `TObjectStrongPtr`, class instances or any **strong references** are destroyed and collected by the garbarge collector. 

However, `TObjectWeakPtr` or soft references has no impact on whether an Object is garbage collected or not, which is only referenced when it used it. 

C++ Smarter pointer is not intended to be used with UObjects, strongly recommended to use `TObjectWeakPtr` or macro instead of the C++ style of smarter pointer, for compatibility with the object management system in Unreal. 

#### Garbage Collection in UE5 and Best Practices 
##### Key Changes

- **API Change**: `MarkPendingKill()` → `MarkAsGarbage()`
- **Behaviour**: Depends on `gc.PendingKillEnabled`:
    - `true` (default): Objects automatically nulled and destroyed (UE4-like behaviour)
    - `false`: Objects only flagged as garbage; require manual reference clearing

##### Reference Management

- **Strong references** (UPROPERTY pointers) keep objects alive
- **Weak pointers** (`TWeakObjectPtr`) don't prevent GC - ideal for non-owning references
- **Raw pointers** need manual clearing for performance-critical code

##### Best Practices

- Use `IsValid()` to check if the pointer is null or garbage
- When `gc.PendingKillEnabled=false`:
    - Pointers won't auto-null
    - Must manually clear references
    - Even destroyed Actors remain in memory until all references are cleared
- Consider implementing `OnDestroyed` callbacks for proper cleanup

#### Summary

Unreal Engine manages all of the objects under its object handling system as `UObject`, which is maintained as the CDO; it is loaded when the engine is running. 

All `UObject`s have a unique macro which makes the object under influence in the engine's object management system, including the garbage collector

Unreal Engine Objects can be updated by the `Tick()` in real-time, and once it is destroyed, the strong references are no longer valid and collected by garbage collector. 

#### References 

[^1]: https://dev.epicgames.com/documentation/en-us/unreal-engine/epic-cplusplus-coding-standard-for-unreal-engine#defaultmemberinitializers

[^2]: https://dev.epicgames.com/documentation/en-us/unreal-engine/creating-objects-in-unreal-engine
